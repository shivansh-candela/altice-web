#!/usr/bin/env python3
# {'FCC0': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 16},
#           'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15}, 'Trial_3': None}, 'FCC1': {
#     'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1163', 'Detected': 'YES',
#                 'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#     'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1163', 'Detected': 'YES',
#                 'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15}, 'Trial_3': None}}
#
# {'FCC0': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 16},
#           'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_3': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_4': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_5': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_6': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_7': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_8': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_9': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                       'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_10': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_11': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_12': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_13': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_14': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_15': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_16': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_17': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_18': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_19': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_20': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_21': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_22': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_23': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_24': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_25': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 16},
#           'Trial_26': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_27': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_28': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_29': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15},
#           'Trial_30': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES',
#                        'Frequency(MHz)': '5500000', 'Detection Time(sec)': 15}, 'Trial_31': None, 'Trial_32': None,
#           'Trial_33': None}}

import sys
import os
import logging
import importlib
import argparse
import time
import datetime
from datetime import datetime
import pandas as pd
import paramiko
from dateutil import parser
import matplotlib.pyplot as plt
import random
import numpy as np
import matplotlib



if sys.version_info[0] != 3:
    logging.critical("This script requires Python 3")
    exit(1)

sys.path.append(os.path.join(os.path.abspath(__file__ + "../../../")))
realm = importlib.import_module("py-json.realm")
Realm = realm.Realm
sniff_radio = importlib.import_module("py-scripts.lf_sniff_radio")
sta_connect = importlib.import_module("py-scripts.sta_connect2")
LFUtils = importlib.import_module("py-json.LANforge.LFUtils")
lf_clean = importlib.import_module("py-scripts.lf_cleanup")
cv_test_reports = importlib.import_module("py-json.cv_test_reports")
lf_report = cv_test_reports.lanforge_reports
lf_report_pdf = importlib.import_module("py-scripts.lf_report")
lf_pcap = importlib.import_module("py-scripts.lf_pcap")
lf_graph = importlib.import_module("py-scripts.lf_graph")


class DfsTest(Realm):
    def __init__(self,
                 host=None,
                 port=None,
                 ssh_username=None,
                 ssh_passwd=None,
                 lf_hackrf=None,
                 ap_name=None,
                 ssid=None,
                 passwd=None,
                 security=None,
                 radio=None,
                 upstream=None,
                 fcctypes=None,
                 channel=None,
                 sniff_radio=None,
                 static=None,
                 static_ip=None,
                 ip_mask=None,
                 gateway_ip=None,
                 enable_traffic=None,
                 desired_detection=None,
                 extra_trials=None,
                 more_option=None,
                 time_int=None,
                 trials=None,
                 bandwidth=None):
        super().__init__(host, port)
        self.host = host
        self.port = port
        self.ssh_username = ssh_username
        self.ssh_password = ssh_passwd
        self.lf_hackrf = lf_hackrf
        self.ap_name = ap_name
        # self.ssid = ssid
        # self.passwd = passwd
        # self.security = security
        self.radio = radio
        self.upstream = upstream
        self.fcctypes = fcctypes
        self.channel = channel
        self.sniff_radio = sniff_radio
        # self.static = static
        # self.static_ip = static_ip
        # self.ip_mask = ip_mask
        # self.gateway_ip = gateway_ip
        # self.enable_traffic = enable_traffic
        self.desired_detection = desired_detection
        self.extra_trials = extra_trials
        self.more_option = more_option
        self.time_int = time_int
        self.trials = trials
        self.bandwidth = bandwidth
        self.pcap_name = None
        self.pcap_obj_2 = None
        self.staConnect = sta_connect.StaConnect2(self.host, self.port, outfile="staconnect2.csv")
        self.local_realm = realm.Realm(lfclient_host=self.host, lfclient_port=self.port)
        self.pcap_obj = lf_pcap.LfPcap()

    def get_station_list(self):
        sta = self.staConnect.station_list()
        if sta == "no response":
            return "no response"
        sta_list = []
        for i in sta:
            for j in i:
                sta_list.append(j)
        return sta_list

    # set channel to parent radio and start sniffing
    def start_sniffer(self, radio_channel=None, radio=None, test_name="dfs_csa_", duration=60):
        self.pcap_name = test_name + str(datetime.now().strftime("%Y-%m-%d-%H-%M")).replace(':', '-') + ".pcap"
        if self.more_option == "centre":
            self.pcap_obj_2 = sniff_radio.SniffRadio(lfclient_host=self.host, lfclient_port=self.port,
                                                     radio=self.sniff_radio, channel=radio_channel,
                                                     monitor_name="monitor", channel_bw="20")
            self.pcap_obj_2.setup(0, 0, 0)
            self.pcap_obj_2.monitor.admin_up()
            print("Waiting until ports appear...")
            x = LFUtils.wait_until_ports_appear(base_url=f"http://{self.host}:{self.port}", port_list="monitor",
                                                debug=True, timeout=300)
            if x is True:
                print("monitor is up ")
                print("start sniffing")
                self.pcap_obj_2.monitor.start_sniff(capname=self.pcap_name, duration_sec=duration)
            else:
                print("some problem with monitor not being up")
                exit()
        elif self.more_option == "random":
            self.pcap_obj_2 = sniff_radio.SniffRadio(lfclient_host=self.host, lfclient_port=self.port,
                                                     radio=self.sniff_radio, channel=radio_channel,
                                                     monitor_name="monitor", channel_bw="20")
            self.pcap_obj_2.setup(1, 1, 1)
            # time.sleep(5)
            self.pcap_obj_2.monitor.admin_up()
            print("Waiting until ports appear...")
            x = LFUtils.wait_until_ports_appear(base_url=f"http://{self.host}:{self.port}", port_list="monitor",
                                                debug=True, timeout=300)
            if x is True:
                print("monitor is up ")
                print("start sniffing")
                self.pcap_obj_2.monitor.start_sniff(capname=self.pcap_name, duration_sec=duration)
            else:
                print("some problem with monitor not being up")
                exit()

    def station_data_query(self, station_name="wlan0", query="channel"):
        # print(station_name)
        sta = station_name.split(".")
        url = f"/port/{sta[0]}/{sta[1]}/{sta[2]}?fields={query}"
        # print("url//////", url)
        response = self.local_realm.json_get(_req_url=url)
        # print("response: ", response)
        if (response is None) or ("interface" not in response):
            print("station_list: incomplete response:")
            # pprint(response)
            exit(1)
        y = response["interface"][query]
        # print(y)
        return y

    def precleanup(self):
        obj = lf_clean.lf_clean(host=self.host,
                                port=self.port,
                                clean_cxs=True,
                                clean_endp=True)
        obj.resource = "all"
        obj.cxs_clean()
        # obj.sta_clean()
        obj.port_mgr_clean()

    def create_client(self, start_id=0, sta_prefix="wlan", num_sta=1):

        local_realm = realm.Realm(lfclient_host=self.host, lfclient_port=self.port)
        station_profile = local_realm.new_station_profile()

        sta_list = self.get_station_list()
        # print(sta_list)
        if not sta_list:
            print("no stations on lanforge")
        else:
            print("clean existing station")
            station_profile.cleanup(sta_list, delay=1)
            LFUtils.wait_until_ports_disappear(base_url=local_realm.lfclient_url,
                                               port_list=sta_list,
                                               debug=True)
            # time.sleep(2)
            print("pre cleanup done")
        station_list = LFUtils.portNameSeries(prefix_=sta_prefix, start_id_=start_id,
                                              end_id_=num_sta - 1, padding_number_=10000,
                                              radio=self.radio)
        station_profile.use_security(self.security, self.ssid, self.passwd)
        station_profile.set_number_template("00")

        station_profile.set_command_flag("add_sta", "create_admin_down", 1)
        station_profile.set_command_flag("set_port", "rpt_timer", 1)
        print("Creating stations.")
        station_profile.create(radio=self.radio, sta_names_=station_list)

        print("Waiting for ports to appear")
        local_realm.wait_until_ports_appear(sta_list=station_list)
        station_profile.admin_up()
        print("Waiting for ports to admin up")

        if self.static:
            sta_list = self.get_station_list()
            port = self.station_data_query(station_name=sta_list[0], query="port")
            port_ = port.split(".")
            set_port = {
                "shelf": port_[0],
                "resource": port_[1],
                "port": port_[2],
                "ip_addr": self.static_ip,
                "netmask": self.ip_mask,
                "gateway": self.gateway_ip,
                "cmd_flags": "NA",
                "current_flags": "NA",
                "mac": "NA",
                "mtu": "NA",
                "tx_queue_len": "NA",
                "alias": "NA",
                "interest": "8552366108"
            }
            self.local_realm.json_post("/cli-json/set_port", set_port)
        print("wait for ip")
        if local_realm.wait_for_ip(station_list):
            print("All stations got IPs")
            return True
        else:
            print("Stations failed to get IPs")
            exit(1)
            return False

    # def run_hackrf(self, width=1, pri=1428, count=18, freq=None):
    #     p = paramiko.SSHClient()
    #     p.set_missing_host_key_policy(
    #         paramiko.AutoAddPolicy())  # This script doesn't work for me unless this line is added!
    #     p.connect(self.host, port=22, username="lanforge", password="lanforge")
    #     p.get_transport()
    #     command = "sudo python lf_hackrf.py --pulse_width " + str(width) + " --pulse_interval " + str(pri) + " --pulse_count " + str(count) + " --sweep_time 1000 --freq " + str(freq) + " --one_burst"
    #     stdin, stdout, stderr = p.exec_command(str(command), get_pty=True)
    #     stdin.write("lanforge\n")
    #     stdin.flush()
    #     opt = stdout.readlines()
    #     opt = "".join(opt)
    #     print(opt)
    #     p.close()

    def run_hackrf(self, freq=None):
        p = paramiko.SSHClient()
        p.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        p.connect(self.host, port=22, username=self.ssh_username, password=self.ssh_password)
        p.get_transport()

        # send frames
        # Execute the first command for scapy logic
        stdin, stdout, stderr = p.exec_command("sudo python scapy_frame.py", get_pty=True)
        stdin.write(str(self.ssh_password) + "\n")
        stdin.flush()
        # Print the output of the first command
        print(stdout.read().decode())
        time.sleep(1)

        command = f"nice -19 python3 lf_hackrf_dfs.py --rf_type FCC0,1,1428,18,20 --lf_hackrf {self.lf_hackrf} --freq {freq} --one_burst --log_level debug"

        # execute second command
        stdin, stdout, stderr = p.exec_command(str(command), get_pty=True)
        stdin.write(str(self.ssh_password) + "\n")
        stdin.flush()
        opt = stdout.readlines()
        opt = "".join(opt)
        print(opt)
        p.close()

        # return current_time

    def stop_sniffer(self):
        print("in stop_sniffer")
        directory = None
        directory_name = "pcap"
        if directory_name:
            directory = os.path.join("", str(directory_name))
        try:

            if not os.path.exists(directory):
                os.mkdir(directory)
        except Exception as x:
            print(x)

        self.pcap_obj_2.monitor.admin_down()
        # time.sleep(2)
        self.pcap_obj_2.cleanup()
        lf_report.pull_reports(hostname=self.host, port=22, username="lanforge",
                               password="lanforge",
                               report_location="/home/lanforge/" + self.pcap_name,
                               report_dir="pcap")
        # time.sleep(10)

        return self.pcap_name

    @property
    def main_logic(self):
        main_dict = dict.fromkeys(self.fcctypes)
        print(main_dict)
        frequency = {}
        centre_freq = {}
        if self.bandwidth == "20":
            frequency = {"52": list(range(5250, 5271)), "56": list(range(5270, 5291)), "60": list(range(5290, 5311)),
                         "64": list(range(5310, 5331)), "100": list(range(5490, 5511)), "104": list(range(5510, 5531)),
                         "108": list(range(5530, 5551)), "112": list(range(5550, 5571)), "116": list(range(5570, 5591)),
                         "120": list(range(5590, 5611)), "124": list(range(5610, 5631)), "128": list(range(5630, 5651)),
                         "132": list(range(5650, 5671)), "136": list(range(5670, 5691)), "140": list(range(5690, 5711))}
            centre_freq = {"52": "5260000", "56": "5280000", "60": "5300000", "64": "5320000", "100": "5500000",
                           "104": "5520000", "108": "5540000", "112": "5560000", "116": "5580000", "120": "5600000",
                           "124": "5620000", "128": "5640000", "132": "5660000", "136": "5680000", "140": "5700000"}
        elif self.bandwidth == "40":
            frequency = {"52": list(range(5250, 5291)), "56": list(range(5250, 5291)), "60": list(range(5290, 5331)),
                         "64": list(range(5290, 5331)), "100": list(range(5490, 5531)), "104": list(range(5490, 5531)),
                         "108": list(range(5530, 5571)), "112": list(range(5530, 5571)), "116": list(range(5570, 5611)),
                         "120": list(range(5570, 5611)), "124": list(range(5610, 5651)), "128": list(range(5610, 5651)),
                         "132": list(range(5650, 5691)), "136": list(range(5650, 5691)), "140": list(range(5690, 5731)),
                         "144": list(range(5690, 5731))}
            centre_freq = {"52": "5270000", "56": "5270000", "60": "5310000", "64": "5310000", "100": "5510000",
                           "104": "5510000", "108": "5550000", "112": "5550000", "116": "5590000", "120": "5590000",
                           "124": "5630000", "128": "5630000", "132": "5670000", "136": "5670000", "140": "5710000",
                           "144": "5710000"}
        elif self.bandwidth == "80":
            frequency = {"52": list(range(5250, 5331)), "56": list(range(5250, 5331)), "60": list(range(5250, 5331)),
                         "64": list(range(5250, 5331)), "100": list(range(5490, 5571)), "104": list(range(5490, 5571)),
                         "108": list(range(5490, 5571)), "112": list(range(5490, 5571)), "116": list(range(5570, 5651)),
                         "120": list(range(5570, 5651)), "124": list(range(5570, 5651)), "128": list(range(5570, 5651)),
                         "132": list(range(5650, 5731)), "136": list(range(5650, 5731)), "140": list(range(5650, 5731)),
                         "144": list(range(5650, 5731))}
            centre_freq = {"52": "5290000", "56": "5290000", "60": "5290000", "64": "5290000", "100": "5530000",
                           "104": "5530000", "108": "5530000", "112": "5530000", "116": "5610000", "120": "5610000",
                           "124": "5610000", "128": "5610000", "132": "5690000", "136": "5690000", "140": "5690000",
                           "144": "5690000"}
        elif self.bandwidth == "160":
            frequency = {"100": list(range(5490, 5651)), "104": list(range(5490, 5651)), "108": list(range(5490, 5651)),
                         "112": list(range(5490, 5651)), "116": list(range(5490, 5651)), "120": list(range(5490, 5651)),
                         "124": list(range(5490, 5651)), "128": list(range(5490, 5651))}
            centre_freq = {"100": "5570000", "104": "5570000", "108": "5570000", "112": "5570000", "116": "5570000",
                           "120": "5570000", "124": "5570000", "128": "5570000"}
        print(frequency[self.channel])
        new_list = []
        for i in frequency[self.channel]:
            new_list.append(str(int(i) * 1000))
        print(new_list)
        t_dict = dict.fromkeys(new_list)
        for i in main_dict:
            main_dict[i] = t_dict.copy()
        print(main_dict)
        list_ = []
        for i in range(self.trials + self.extra_trials):
            var = 000
            var_1 = "Trial_" + str(var + i + 1)
            list_.append(var_1)
        sec_dict = dict.fromkeys(list_)
        for fcc in main_dict:
            for i in new_list:
                main_dict[fcc][i] = sec_dict.copy()
        print(main_dict)

        #        fcc0 { freq : {tria:}}}
        # ***************************************************
        width_, interval_, count_ = "", "", ""

        for fcc in self.fcctypes:
            for frq in new_list:
                for tria in range(self.trials):
                    var = 000
                    var_1 = "Trial_" + str(var + tria + 1)
                    new_list = ["Burst", "Pulses", "Width", "PRI(US)", "Detected", "Frequency(MHz)",
                                "Detection Time(sec)", "Freq_offset"]
                    third_dict = dict.fromkeys(new_list)
                    main_dict[fcc][frq][var_1] = third_dict.copy()
                    print(main_dict)

                    # standard = {"FCC0": {"width_": "1", "interval_": "1428", "count_": "18"}, "FCC1": {}}

                    if fcc == "FCC0":
                        width_ = "1"
                        interval_ = "1428"
                        count_ = "18"



                    main_dict[fcc][frq][var_1]["Burst"] = "1"
                    main_dict[fcc][frq][var_1]["Pulses"] = count_
                    main_dict[fcc][frq][var_1]["Width"] = width_
                    main_dict[fcc][frq][var_1]["PRI(US)"] = interval_

                    main_dict[fcc][frq][var_1]["Frequency(MHz)"] = frq
                    diff = (int(frq) - int(centre_freq[self.channel])) / 1000
                    val = str(diff)
                    main_dict[fcc][frq][var_1]["Freq_offset"] = val
                    # if centre_freq[self.channel] < frq:
                    #     diff = int(centre_freq[self.channel]) - int(frq)
                    #     val = str(diff)
                    #     main_dict[fcc][frq][var_1]["Freq_offset"] = val
                    # else:
                    #     diff = int(centre_freq[self.channel]) - int(frq)
                    #     val = str(diff)
                    #     main_dict[fcc][frq][var_1]["Freq_offset"] = val


                    print("starting sniffer")
                    self.start_sniffer(radio_channel=self.channel, radio=self.sniff_radio,
                                       test_name="dfs_csa_" + str(fcc) + "_" + str(var_1) + "_channel" + str(self.channel) + "_")


                    # print(type(current_time))

                    print("generate radar")
                    self.run_hackrf(freq=frq)

                    current_time = datetime.now()
                    print("Current date and time : ")
                    current_time = current_time.strftime("%b %d, %Y  %H:%M:%S")
                    print("time stamp of radar send", current_time)
                    # time.sleep(15)
                    print("stop sniffer")
                    time.sleep(2)
                    file_name_ = self.stop_sniffer()
                    file_name = "./pcap/" + str(file_name_)
                    print("pcap file name", file_name)

                    # pcap read logic

                    # csa_frame = self.pcap_obj.check_frame_present(
                    #     pcap_file=str(file_name),
                    #     filter='wlan.csa.channel_switch.count ')
                    # print("csa frame", csa_frame)
                    # if len(csa_frame) != 0 and csa_frame != "empty":
                    #     print("csa frame  is present")
                    #     print("radar detected")
                    #     main_dict[fcc][frq][var_1]["Detected"] = "YES"
                    #     csa_frame_time = self.pcap_obj.read_arrival_time(
                    #         pcap_file=str(file_name),
                    #         filter='wlan.csa.channel_switch.count ')
                    #     print("csa frame  time is ", csa_frame_time)
                    #     csa_time = str(csa_frame_time)
                    #     csa_frame_time_ = None
                    #     for i in csa_time:
                    #         if i == ".":
                    #             print("yes")
                    #             ind = csa_time.index(".")
                    #             csa_frame_time_ = csa_time[:ind]
                    #     print("csa time", csa_frame_time_)
                    #
                    #     print("calculate detection time")
                    #     FMT = '%b %d, %Y %H:%M:%S'
                    #     print("$$$$", datetime.strptime(csa_frame_time_, FMT))
                    #     print("^^^6", datetime.strptime(current_time, FMT))
                    #     c_time = datetime.strptime(csa_frame_time_, FMT) - datetime.strptime(current_time, FMT)
                    #     print("detection time ", c_time)
                    #     lst = str(c_time).split(":")
                    #     seconds = int(lst[0]) * 3600 + int(lst[1]) * 60 + int(lst[2])
                    #     d_time = seconds
                    #     print("detection time ", d_time)
                    #     main_dict[fcc][frq][var_1]["Detection Time(sec)"] = d_time

                    scapy_frame = self.pcap_obj.check_frame_present(pcap_file=str(file_name),
                                                                    filter="(wlan.sa == 00:11:22:33:44:55)")
                    print("scapy frame +", scapy_frame)
                    scapy_frame_time_ = None
                    if len(scapy_frame) != 0 and scapy_frame != "empty":
                        print("scapy frame  is present")
                        logging.info("scapy frame  is present")

                        scapy_frame_time = self.pcap_obj.read_arrival_time(
                            pcap_file=str(file_name),
                            filter="(wlan.sa == 00:11:22:33:44:55)")
                        print("scapy frame  time is ", scapy_frame_time)
                        logging.info("csa frame  time is " + str(scapy_frame_time))
                        scapy_time = str(scapy_frame_time)

                        # for i in scapy_time:
                        #     if i == "I":
                        #         print("yes")
                        #         logging.info("yes")
                        #         ind = scapy_time.index("I")
                        #         scapy_frame_time_ = scapy_time[:int(ind) - 1]
                        # print("scapy time", scapy_frame_time_)
                        # logging.info("scapy time" + str(scapy_frame_time_))

                    csa_frame = self.pcap_obj.check_frame_present(
                        pcap_file=str(file_name),
                        filter="wlan.csa.channel_switch.count")
                    print("csa frame", csa_frame)
                    logging.info("csa frame" + str(csa_frame))
                    if len(csa_frame) != 0 and csa_frame != "empty":
                        print("csa frame  is present")
                        logging.info("csa frame  is present")
                        print("radar detected")
                        logging.info("radar detected")
                        main_dict[fcc][frq][var_1]["Detected"] = "YES"
                        csa_frame_time = self.pcap_obj.read_arrival_time(
                            pcap_file=str(file_name),
                            filter="wlan.csa.channel_switch.count")
                        print("csa frame  time is ", csa_frame_time)
                        logging.info("csa frame  time is " + str(csa_frame_time))
                        csa_time = str(csa_frame_time)
                        csa_frame_time_ = None
                        # commenting this loop for to run on all timezones
                        # for i in csa_time:
                        #     if i == "I":
                        #         print("yes")
                        #         logging.info("yes")
                        #         ind = csa_time.index("I")
                        #         csa_frame_time_ = csa_time[:int(ind) - 1]
                        # print("csa time", csa_frame_time_)
                        # logging.info("csa time" + str(csa_frame_time_))

                        print("csa fra")
                        print(scapy_frame_time_)
                        print(type(scapy_frame_time_))
                        print("csa_frame,", csa_frame_time_)
                        print(type(csa_frame_time_))
                        print("calculate detection time")
                        logging.info("calculate detection time")
                        csa_datetime = parser.parse(csa_frame_time)
                        scapy_datetime = parser.parse(scapy_frame_time)

                        # Calculate the time difference
                        time_difference = round((csa_datetime - scapy_datetime).total_seconds(), 1)

                        print(time_difference)

                        print("detection time ", time_difference)
                        logging.info("detection time " + str(time_difference))
                        main_dict[fcc][frq][var_1]["Detection Time(sec)"] = time_difference

                    else:
                        # print("csa frame is not present")
                        # print("radar not detected")
                        # main_dict[fcc][frq][var_1]["Detected"] = "NO"
                        # main_dict[fcc][frq][var_1]["Detection Time(sec)"] = "NA"
                        print("csa frame is not present")
                        logging.info("csa frame is not present")
                        print("radar not detected")
                        logging.info("radar not detected")
                        main_dict[fcc][frq][var_1]["Detected"] = "NO"
                        main_dict[fcc][frq][var_1]["Detection Time(sec)"] = "NA"


                    print(main_dict)

        print("final dict", main_dict)
        return main_dict


    def run(self):
        print(self.fcctypes)
        test_time = datetime.now()
        test_time = test_time.strftime("%b %d %H:%M:%S")
        print("Test started at ", test_time)
        logging.info("Test started at " + str(test_time))
        # starting dpt logic

        main = self.main_logic
        test_end = datetime.now()
        test_end = test_end.strftime("%b %d %H:%M:%S")
        print("Test ended at ", test_end)
        logging.info("Test ended at " + test_end)
        s1 = test_time
        s2 = test_end  # for example
        FMT = '%b %d %H:%M:%S'
        test_duration = datetime.strptime(s2, FMT) - datetime.strptime(s1, FMT)
        print(test_duration)
        self.generate_report(test_duration=test_duration, main_dict=main)



    def test_graph(self, graph_dict=None):
        self.graph_image_name = "overall"
        x = []
        for i in graph_dict:
            x.append(i)
        pass_per = []
        fail_per = []
        for i in graph_dict:

            pass_per.append(graph_dict[i])
            fail_per.append(round((float(100 - graph_dict[i])), 1))

        plt.rcParams["figure.figsize"] = [15, 7]
        plt.rcParams["figure.autolayout"] = True

        year = x
        issues_addressed = pass_per
        issues_pending = fail_per

        b1 = plt.barh(year, issues_addressed, color="green")

        b2 = plt.barh(year, issues_pending, left=issues_addressed, color="red")
        for i, v in enumerate(issues_addressed):
            if v != 0:
                plt.text(v * 0.45, i + .145, "%s%s" % (v, "%"), color='white', fontweight='bold', fontsize=10,
                         ha='center', va='center')
        for i, v in enumerate(issues_pending):
            if v != 0:
                plt.text(v * 0.45 + issues_addressed[i], i + .145, "%s%s" % (v, "%"), color='white', fontweight='bold',
                         fontsize=10,
                         ha='center', va='center')

        plt.legend([b1, b2], ["PASS", "FAIL"], title="Issues", bbox_to_anchor=(1.05, 1.0), loc="upper left")
        plt.xticks([])
        plt.savefig("%s.png" % self.graph_image_name, dpi=96)
        return "%s.png" % self.graph_image_name



    def generate_report(self, test_duration="1:26:07",  main_dict=None):
        # main_dict = {'FCC0': {'5490000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5490000', 'Detection Time(sec)': 17, 'Freq_offset': '-10.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5490000', 'Detection Time(sec)': 18, 'Freq_offset': '-10.0'}}, '5491000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5491000', 'Detection Time(sec)': 18, 'Freq_offset': '-9.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5491000', 'Detection Time(sec)': 18, 'Freq_offset': '-9.0'}}, '5492000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5492000', 'Detection Time(sec)': 18, 'Freq_offset': '-8.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5492000', 'Detection Time(sec)': 18, 'Freq_offset': '-8.0'}}, '5493000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5493000', 'Detection Time(sec)': 18, 'Freq_offset': '-7.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5493000', 'Detection Time(sec)': 17, 'Freq_offset': '-7.0'}}, '5494000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5494000', 'Detection Time(sec)': 17, 'Freq_offset': '-6.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5494000', 'Detection Time(sec)': 17, 'Freq_offset': '-6.0'}}, '5495000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'NO', 'Frequency(MHz)': '5495000', 'Detection Time(sec)': 'NA', 'Freq_offset': '-5.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5495000', 'Detection Time(sec)': 18, 'Freq_offset': '-5.0'}}, '5496000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5496000', 'Detection Time(sec)': 17, 'Freq_offset': '-4.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5496000', 'Detection Time(sec)': 18, 'Freq_offset': '-4.0'}}, '5497000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5497000', 'Detection Time(sec)': 18, 'Freq_offset': '-3.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5497000', 'Detection Time(sec)': 18, 'Freq_offset': '-3.0'}}, '5498000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5498000', 'Detection Time(sec)': 18, 'Freq_offset': '-2.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5498000', 'Detection Time(sec)': 18, 'Freq_offset': '-2.0'}}, '5499000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5499000', 'Detection Time(sec)': 17, 'Freq_offset': '-1.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5499000', 'Detection Time(sec)': 18, 'Freq_offset': '-1.0'}},'5500000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5500000', 'Detection Time(sec)': 17, 'Freq_offset': '0.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5500000', 'Detection Time(sec)': 18, 'Freq_offset': '0.0'}},'5501000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5501000', 'Detection Time(sec)': 17, 'Freq_offset': '1.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5501000', 'Detection Time(sec)': 18, 'Freq_offset': '1.0'}},'5502000': {'Trial_1':{'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5502000', 'Detection Time(sec)': 17, 'Freq_offset': '2.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5502000', 'Detection Time(sec)': 18, 'Freq_offset': '2.0'}}, '5503000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5503000', 'Detection Time(sec)': 17, 'Freq_offset': '3.0'}, 'Trial_2':{'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5503000', 'Detection Time(sec)': 18, 'Freq_offset': '3.0'}}, '5504000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5504000', 'Detection Time(sec)': 17, 'Freq_offset': '4.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5504000', 'Detection Time(sec)': 18, 'Freq_offset': '4.0'}},'5505000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5505000', 'Detection Time(sec)': 17, 'Freq_offset': '5.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5505000', 'Detection Time(sec)': 18, 'Freq_offset': '5.0'}},'5506000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5506000', 'Detection Time(sec)': 17, 'Freq_offset': '6.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5506000', 'Detection Time(sec)': 18, 'Freq_offset': '6.0'}},'5507000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5507000', 'Detection Time(sec)': 17, 'Freq_offset': '7.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5507000', 'Detection Time(sec)': 18, 'Freq_offset': '7.0'}},'5508000': {'Trial_1': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5508000', 'Detection Time(sec)': 17, 'Freq_offset': '8.0'}, 'Trial_2':{'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5508000', 'Detection Time(sec)': 18, 'Freq_offset': '8.0'}},'5509000': {'Trial_1':{'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5509000', 'Detection Time(sec)': 17, 'Freq_offset': '9.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5509000', 'Detection Time(sec)': 18, 'Freq_offset': '9.0'}},'5510000': {'Trial_1':{'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5510000', 'Detection Time(sec)': 17, 'Freq_offset': '10.0'}, 'Trial_2': {'Burst': '1', 'Pulses': '18', 'Width': '1', 'PRI(US)': '1428', 'Detected': 'YES', 'Frequency(MHz)': '5510000', 'Detection Time(sec)': 18, 'Freq_offset': '10.0'}}}}
        print("test duration", test_duration)
        report = lf_report_pdf.lf_report(_path="", _results_dir_name="Detection Bandwidth Test", _output_html="dpt.html",
                                         _output_pdf="dpt.pdf")

        date = str(datetime.now()).split(",")[0].replace(" ", "-").split(".")[0]
        report_path = report.get_report_path()
        print(report_path)
        # report.move_data(directory_name="pcap")

        test_setup_info = {
            "DUT Name": self.ap_name,
            "Test Duration": test_duration,
        }
        report.set_title("Detection Bandwidth  Test Report")
        report.set_date(date)
        report.build_banner_cover()
        report.set_table_title("Test Setup Information")
        report.build_table_title()

        report.test_setup_table(value="Device under test", test_setup_data=test_setup_info)

        report.set_obj_html("Objective", "Detection Bandwidth Test  is compliance to the Dynamic Frequency Selection"
                                         " (DFS) Regulation, The purpose of this test is to subject the DUT  to a Type 0 FCC radar pulse"
                                         "while moving the frequency of the radar signal through the channel to characterized range of frequencies over which"
                                         "the DUT can detect the radar pulse.")
        report.build_objective()
        report.set_obj_html("Result Summary", "The below graph provides information regarding detection probability percentage for various RADAR Types.")
        report.build_objective()
        graph_dict = dict.fromkeys(self.fcctypes)
        for fcc in self.fcctypes:
            detection_list = []
            for i in main_dict[fcc]:
                if main_dict[fcc][i] == None:
                    print("/n")
                else:
                    for j in main_dict[fcc][i]:
                        detection_list.append(main_dict[fcc][i][j]["Detected"])
            print("detection list", detection_list)
            m = None
            for i in detection_list:
                if i == 'YES':
                    m = detection_list.count("YES")
                    print(m)
                else:
                    if len(detection_list) == 1:
                        m = 0
                        print("\n")
            result1 = all(element == "NO" for element in detection_list)
            if result1:
                m = 0
            if len(detection_list) == 0:
                print("/n")
                graph_dict[fcc] = "0"

            else:
                percent = round(((m / len(detection_list)) * 100), 1)
                print(percent)
                graph_dict[fcc] = percent

        print("graph dict", graph_dict)

        graph2 = self.test_graph(graph_dict=graph_dict)
        # graph1 = self.generate_per_station_graph()
        report.set_graph_image(graph2)
        report.move_graph_image()
        report.build_graph()

        # graph ka code

        # various atandards
        required_percent = {"FCC0": "60%"}

        report.set_obj_html("Summary Table",
                            "The below table provides detailed information regarding detection probability percentage for various RADAR Types.")
        report.build_objective()
        wave, pd_per, pd_req, tring, avg_detect, result = [], [], [], [], [], []


        for fcc in self.fcctypes:
            wave.append(fcc)

            # PD LOGIC
            detection_list = []
            for i in main_dict[fcc]:
                if main_dict[fcc][i] == None:
                    print("/n")
                else:
                    for j in main_dict[fcc][i]:
                        detection_list.append(main_dict[fcc][i][j]["Detected"])
            print("detection list", detection_list)
            m = None

            if 'YES' in detection_list:
                m = detection_list.count("YES")
                print(m)
            else:
                result1 = all(element == "NO" for element in detection_list)
                if result1:
                    m = 0
            if len(detection_list) == 0:
                print("/n")
                pd_per.append("0")
            else:
                percent = round(((m / len(detection_list)) * 100), 1)
                print(percent)
                pd_per.append(percent)
                if percent >= self.desired_detection:
                    result.append("PASSED")
                else:
                    result.append("FAILED")

            pd_req.append(required_percent[fcc])


            # average detection time
            detection_list = []
            for i in main_dict[fcc]:
                if main_dict[fcc][i] == None:
                    print("/n")
                else:
                    for j in main_dict[fcc][i]:
                        detection_list.append(main_dict[fcc][i][j]['Detection Time(sec)'])
            print("detection list", detection_list)
            result1 = all(element == "NA" for element in detection_list)
            if len(detection_list) == 0:
                print("/n")
                avg_detect.append("0")
            else:
                if result1:
                    avg_detect.append(0)
                else:
                    sum = 0
                    for i in detection_list:
                        val = None
                        if i == "NA":
                            val = 0
                        else:
                            val = i

                        sum = sum + int(val)
                        print(sum)

                    av = round(((sum / len(detection_list))), 1)
                    print(av)
                    avg_detect.append(av)
        print("table")
        print(wave)
        print(pd_per)
        print(pd_req)
        print(avg_detect)
        print(result)

        table_1 = {
            "WaveForm Name": wave,
            "Detected BW": self.bandwidth + " mhz ( -10 : 0: +10)",
            "% BW detected": pd_per,
            "Required Percentage ": self.desired_detection,
            "Average Detect Time (secs)": avg_detect,
            "Result": result,
        }
        test_setup = pd.DataFrame(table_1)
        report.set_table_dataframe(test_setup)
        report.build_table()

        centre_freq = {"52": "5260000", "56": "5280000", "60": "5300000", "64": "5320000", "100": "5500000",
                       "104": "5520000", "108": "5540000", "112": "5560000", "116": "5580000", "120": "5600000",
                       "124": "5620000", "128": "5640000", "132": "5660000", "136": "5680000", "140": "5700000"}

        for fcc in self.fcctypes:

            Trials, avg_det_time, pass_per, Result, pri, frequency, det_time, frq_offset = [], [], [], [], [], [], [], []
            off_set = []
            for i in main_dict[fcc]:
                d_list = []
                detect = []
                frequency.append(i)

                val = (int(i) - int(centre_freq[self.channel])) / 1000
                print(val)
                off_set.append(int(val))
                Trials.append(self.trials)
                for j in main_dict[fcc][i]:
                    print(j)
                    d_list.append(main_dict[fcc][i][j]['Detection Time(sec)'])
                    detect.append(main_dict[fcc][i][j]['Detected'])
                print("detection time ", d_list)
                det_time.append(d_list[0])
                print("detection time ", det_time)

                print("detect list", detect)


                # avg
                sum = 0
                for m in d_list:
                    val = None
                    if m == "NA":
                        val = 0
                    else:
                        val = m
                    sum = sum + int(val)
                avg = sum / len(d_list)
                print(avg)
                avg_det_time.append(avg)

                # detect percen
                sum = 0
                for i in detect:
                    val = None
                    if i == "NO":
                        val = 0
                    else:
                        val = 1

                    sum = sum + int(val)
                    print(sum)
                # sum = 0
                # if "YES" in detect:
                #     sum = sum + 1

                per = round(((sum / len(detect)) * 100), 1)
                print(per)
                pass_per.append(per)

                if float(per) >= self.desired_detection:
                    Result.append("PASSED")
                else:
                    Result.append("FAILED")

            report.set_obj_html("Per Radar Type Summary Table",
                                "The below table provides detailed information  RADAR Type FCC0.")
            report.build_objective()


            table_3 = {
                "Frequency(MHz)": frequency,
                "Frequency Offset": off_set,
                "No of Trials": Trials,
                "Average Detect Time": avg_det_time,
                "Pass %": pass_per,
                "Result": Result,
            }
            test_setup = pd.DataFrame(table_3)
            report.set_table_dataframe(test_setup)
            report.build_table()

        report.set_obj_html("Detailed Result Table",
                            "The below tables provides detailed information for per trials run for each RADAR Types")
        report.build_objective()
        for fcc in self.fcctypes:
            report.set_obj_html("Detailed Result Table for " + str(fcc),
                                "The below table provides detailed information for per trials run for " + str(fcc) + "RADAR Type")
            report.build_objective()

            Trials, burst, pulse, width, pri, detect, frequency, det_time, frq_offset = [], [], [], [], [], [], [], [], []

            for i in main_dict[fcc]:
                print(i)
                if main_dict[fcc][i] == None:
                    print("ignore")


                else:
                    for j in main_dict[fcc][i]:
                        Trials.append(j)
                        burst.append(main_dict[fcc][i][j]['Burst'])
                        pulse.append(main_dict[fcc][i][j]['Pulses'])
                        width.append(main_dict[fcc][i][j]['Width'])
                        pri.append(main_dict[fcc][i][j]['PRI(US)'])
                        detect.append(main_dict[fcc][i][j]['Detected'])
                        frequency.append(main_dict[fcc][i][j]['Frequency(MHz)'])
                        det_time.append(main_dict[fcc][i][j]['Detection Time(sec)'])
                        frq_offset.append(main_dict[fcc][i][j]['Freq_offset'])

            print("trial", Trials)
            table_2 = {
                "Trials": Trials,
                "Frequency (MHz)": frequency,
                "Frequency offset": frq_offset,
                "Num Bursts": burst,
                "Num Pulses": pulse,
                "Pulse Width (us)": width,
                "PRI(us)": pri,
                "Detected": detect,
                "Detection Time(secs)": det_time
            }
            test_setup_ = pd.DataFrame(table_2)
            report.set_table_dataframe(test_setup_)
            report.build_table()

        freq_option = None
        if self.more_option == "centre":
            freq_option = "Stay at centre freq for all Trials"
        elif self.more_option == "random":
            freq_option = "Stay at random frequency between the bandwidth for all trials"
        test_input_infor = {
            "Parameters": "Values",
            "LANforge ip": self.host,
            "LANforge port": self.port,
            "Radar Types": self.fcctypes,
            "Radar Hardware": "ct712",
            "Freq Channel Number": self.channel,
            "Desired Pass Percentage": str(self.desired_detection) + str("%"),
            "Time interval between Trials (secs)": "2",
            "Run Traffic": False,

            "Contact": "support@candelatech.com"
        }
        report.set_table_title("Test basic Information")
        report.build_table_title()
        report.test_setup_table(value="Information", test_setup_data=test_input_infor)

        report.build_footer()
        report.write_html()
        report.write_pdf_with_timestamp(_page_size='A4', _orientation='Portrait')


def main():
    parser = argparse.ArgumentParser(prog=__file__,
                                     formatter_class=argparse.RawTextHelpFormatter,
                                     description="""
NAME: detection_bw_test.py

PURPOSE:
         Need to Update the purpose...

EXAMPLE:
        # To run the bandwidth test on bandwidth 20MHz.

             ./detection_bw_test.py --host 192.168.200.91 --sniff_radio 1.1.wiphy1 --fcctypes FCC0 --channel 64 
             --trial 1 --desired_detection 90 --more_option centre --bw 20

SCRIPT_CLASSIFICATION: Report Generation

SCRIPT_CATEGORIES: Bandwidth Testing 

NOTES:

STATUS: Functional

VERIFIED_ON:   14-SEP-2023,
             GUI Version:  5.4.6
             Kernel Version: 5.19.17+

LICENSE:
          Free to distribute and modify. LANforge systems must be licensed.
          Copyright 2023 Candela Technologies Inc

INCLUDE_IN_README: False
""")

    parser.add_argument("--host", help='specify the GUI ip to connect to', default='192.168.1.31')

    parser.add_argument("--port", help="specify scripting port of LANforge", default=8080)

    parser.add_argument("--ssh_username", help='provide username for doing ssh into LANforge', default="lanforge")

    parser.add_argument("--ssh_password", help='provide password for doing ssh into LANforge', default="lanforge")

    parser.add_argument("--lf_hackrf", help='provide serial number og tx hackrf eg 30a28607', default="30a28607")
    parser.add_argument("--ap_name", help='provied the dut name, which need to be test.', default="Test_AP")
    parser.add_argument("--sniff_radio", help="radio at which wireshark will be started", default="1.1.wiphy0")

    parser.add_argument('--fcctypes', help='types needed to be tested FCC0', nargs="+", default=["FCC0"])

    parser.add_argument('--channel',
                        help='channel options need to be tested {52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124 ,128, 132, 136, 140}',
                        type=str, default="100")

    parser.add_argument("--trials", help="provide the number of trials you want to test default is 30", type=int,
                        default=30)

    parser.add_argument("--desired_detection",
                        help="provide the percentage value for desired detection eg 80, which means 80%%", type=int,
                        default=80)

    parser.add_argument("--extra_trials",
                        help="provide the number of extra trials need to be performed if the test doesnot reach the expected or desired value",
                        type=int, default=0)

    parser.add_argument("--more_option",
                        help="select from the list of more options which test you need to perform [centre, random]",
                        default="centre")

    parser.add_argument("--time_int", default="0", help="provide time interval in seconds between each trials")

    parser.add_argument("--bw", help="Setting the bandwidth", default="20")

    # parser.add_argument('--ssid', type=str, help='ssid for client')
    #
    # parser.add_argument('--passwd', type=str, help='password to connect to ssid', default='[BLANK]')
    #
    # parser.add_argument('--security', type=str, help='security', default='open')

    # parser.add_argument('--radio', type=str, help='radio at which client will be connected', default='1.1.wiphy1')

    # parser.add_argument("--static", default=True, help="True if client will be created with static ip")

    # parser.add_argument("--static_ip", default="192.168.2.100", help="if static option is True provide static ip to client")
    #
    # parser.add_argument("--ip_mask", default="255.255.255.0", help="if static is true provide ip mask to client")
    #
    # parser.add_argument("--gateway_ip", default="192.168.2.50", help="if static is true provide gateway ip")

    # parser.add_argument('--upstream', type=str, help='provide eth1/eth2', default='eth1')

    # parser.add_argument("--enable_traffic", help="set to True if traffic needs to be added while testing",
    #                     default=False)

    args = parser.parse_args()
    obj = DfsTest(host=args.host,
                  port=args.port,
                  ssh_username=args.ssh_username,
                  ssh_passwd=args.ssh_password,
                  lf_hackrf=args.lf_hackrf,
                  ap_name=args.ap_name,
                  sniff_radio=args.sniff_radio,
                  # ssid=args.ssid,
                  # passwd=args.passwd,
                  # security=args.security,
                  # radio=args.radio,
                  # upstream=args.upstream,
                  fcctypes=args.fcctypes,
                  channel=args.channel,
                  trials=args.trials,
                  # static=args.static,
                  # static_ip=args.static_ip,
                  # ip_mask=args.ip_mask,
                  # gateway_ip=args.gateway_ip,
                  # enable_traffic=args.enable_traffic,
                  desired_detection=args.desired_detection,
                  extra_trials=args.extra_trials,
                  more_option=args.more_option,
                  time_int=args.time_int,
                  bandwidth=args.bw)
    obj.run()

if __name__ == '__main__':
    main()